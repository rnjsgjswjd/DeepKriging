---
title: "PMcode"
author: "Yuxiao Li"
date: "4/8/2020"
output: html_document
---


```{r}
rm(list=ls())
```

# Data load

 - `kriging.csv`: 기후자료와 미세먼지 자료를 병합한 데이터, 파이썬(Applicaiton_Study.ipynb)파일 실행하면 얻을 수 있음.

```{r}
library(sf)
library(maps)

# 여기서 kriging데이터는 파이썬에서 기후자료와 미세먼지 자료를 병합한 자료
data_kriging <- read.csv("kriging.csv",header = TRUE)
names(data_kriging) <- c("index","long","lat","prec","temp","pres","rh","uwind","vwind","pm25","pm25_class","pm25_log")

test_idx <- read.csv("test_idx.csv",header = TRUE)
```


```{r}
dim(data_kriging)
```

# Variogram fitting

## Variogram cloud

```{r}
library(geoR)
vag_data <- data_kriging[,c("long","lat","pm25")]
est_vario_classic <- variog(coords = vag_data[, 1:2], data = vag_data$pm25 , option = "bin",
                            max.dist = 1, estimator.type='classical',message=FALSE)

plot(est_vario_classic ,main='variogram', col='black', ylab='',pch=19)
lines(est_vario_classic, type='l', lty=2, col='red', ylab='',lwd=1.5)

```

## Parametic Model fitting

### Matern Model

```{r}
est_variog <- variog(coords = vag_data[, 1:2], data = vag_data$pm25,
                     max.dist = 1, estimator.type='classical', message=FALSE)
# ols 터짐
# ols=variofit(est_variog, ini=c(10, 0.3),cov.model='mat',
#             fix.kappa=FALSE, kap=1.5, nug=5, weights='equal', messages=FALSE)

wls=variofit(est_variog, ini=c(10, 0.3), cov.model='mat', 
             fix.kappa=FALSE, kap=1.5, nug=5, weights='cressie',messages=FALSE)

par(cex=0.7,cex.lab=2,cex.main=1.5,oma=c(0,1,0,0))

plot(est_variog,main='',col='blue',lwd=2)
#lines(ols,lwd=1.5)
lines(wls,lty=2,lwd=1.5)
#legend('bottomright',c('ols','wls'),
#       col=c('black','black'), lty=c(1,2), cex=3)
``` 

```{r}
# 추정 결과 확인
wls
```

추정된 Matern Model의 smoothness parameter$\kappa$가 27.5로 추정되었으므로, 차라리 가우시안 모형을 사용하는 것이 더 적절할 것으로 보입니다.

따라서, 가우시안 및 다양한 모형을 사용하여 추정을 진행해 보겠습니다.

```{r}
# 가우시안
wls_gau=variofit(est_variog, ini=c(10, 0.3), cov.model='gaussian', 
                 nug=5, weights='cressie',messages=FALSE)
# 지수
wls_exp=variofit(est_variog, ini=c(10, 0.3), cov.model='exponential', 
                 nug=5, weights='cressie',messages=FALSE)
# 스페리컬
wls_sph=variofit(est_variog, ini=c(10, 0.3), cov.model='spherical', 
                 nug=5, weights='cressie',messages=FALSE)

par(cex=0.7,cex.lab=2,cex.main=1.5,oma=c(0,1,0,0))

plot(est_variog,main='',col='blue',lwd=3)
lines(wls_gau,lty=1,lwd=2,col='red')
lines(wls_exp,lty=2,lwd=2,col='green')
lines(wls_sph,lty=3,lwd=2,col='purple')
lines(wls,lty=4,lwd=2,col='orange')
legend('bottomright',c('gaussian','exponential','spherical','matern'),
       col=c('red','green','purple','orange'), lty=1:4, cex=2)
```

```{r}
# 추정 결과 한번에 확인
wls_gau
wls_exp
wls_sph
wls
```

Minimised weighted sum of squares값이 가장 작은 `spherical`모형을 사용하는 것이 가장 적절해 보입니다.

# [CV] Cross Validation: Universal Kriging

## Universal Kriging in R

Universal Kriging은 Simple, Ordinary Kriging과 다르게 Observation location과 Prediction location의 Covariate 정보까지 고려해서 Kriging을 수행하는 방법입니다. 아래 코드 블럭의 Parameter Estimation과 Kriging 수행을 위한 코드는 아래와 같습니다. 

**Geodata for Universal Kriging**

Universal Kriging을 위해서는 같은 위치에서 어떤 colunm이 target(observed process)이고 어떤 colunm이 covariate인지를 명확히 해야합니다. 이때, `as.geodata()` 함수를 사용하여 `geodata` 객체를 생성합니다. 중요 옵션은 다음과 같습니다.

 - `coords.col`: 위도, 경도 정보가 있는 열을 설정
 - `data.col`: target이 있는 열을 설정
 - `covar.col`: covariate이 있는 열을 설정

**Estimation**

여기서 Parameter Estimation은 *ML* 방법을 사용하여 $\beta$ 및 공분산 함수 모수를 추정합니다. 이때, `likfit()` 함수를 사용하여 추정을 수행합니다. 중요 옵션은 다음과 같습니다.

 - `cov.model`: 공분산 함수를 설정합니다. 여기서는 `spherical`을 사용하였습니다.
 - `trend`: covarate에 대한 Trend를 설정합니다. 여기서는 `"1st"` 즉, 선형관계를 설정 하였습니다. 이는 다음과 같은 모형을 고려한 것입니다.
 
 $$
 Z(s) = X(s)\boldsymbol{\beta} + \nu(s) + \epsilon(s), \; s \in D \subset \mathbb{R}^2
 $$
 
여기서 $Z(s)$는 Obseved Process, $X(s)$는 Covariate, $\boldsymbol{\beta}$는 covariate에 대한 계수, $\nu(s)$는 Spatial process, $\epsilon(s)$는 white-noise process를 의미합니다. 
 
 - `add.to.trend`: 옵션을 사용하여 사용된 covariate를 설정합니다. 여기서는 `~prec+temp+pres+rh+uwind+vwind`로 설정하여, 모든 covariate를 사용하였습니다.

**Universal Kriging**

우선 `krige.control()` 함수를 사용하여 Kriging Object를 생성합니다. 중요 옵션은 다음과 같습니다.

 - `type.krige`: Kriging 방법을 설정합니다. 여기서는 `"OK"` 즉, Ordinary Kriging을 사용하였습니다. 이때, 아래 옵션들을 사용해야 Universal Kriging을 수행할 수 있습니다.
 - `trend.d`: train(observed) 데이터에 대한 Trend를 설정
 - `trend.l`: valid(prediction) 데이터에 대한 Trend를 설정, 여기서 두 옵션 모두 `"1st"`로 설정하여, data에 대해서도 선형추세(평균), prediction point의 covariate에 대해서도 선형추세(평균)을 가정
 - `obj.model`: Universal Kriging을 수행하기 위한 객체 모델(사용되는 모수들)을 지정

그 다음 위에서 생성한 `krige.control()` 객체를 `krige.conv()` 함수에 넣어서 Kriging을 수행합니다. 이때, 주요 옵션은 다음과 같습니다.

 - `geodata`: train(observed) 데이터에 대한 `geodata` 객체
 - `locations`: prediction point의 위치
 - `krige`: `krige.control()` 객체

```{r}
library(geoR) 
library(caret)

# 빈벡터 생성
mse = mae = acc = c()

# start_time <- Sys.time()

# 폴드 진행
for (i in 1:10){
  cat("Fold: ",i,"\n")
    idx = na.exclude(test_idx[,i+1])
    
    # Train, Valid 데이터 분할
    train_kriging=data_kriging[-idx,]
    valid_kriging=data_kriging[idx,]
    
    # geodata 객체 생성
    geodata_train = as.geodata(train_kriging, coords.col = 2:3, data.col = 10, covar.col = 4:9)
    geodata_valid = as.geodata(valid_kriging, coords.col = 2:3, data.col = 10, covar.col = 4:9)
    
    
    # ML방법 Beta 및 공분산 함수 모수 추정
    geoR_fit = likfit(geodata_train, ini.cov.pars = c(18, 0.5), negget=3, cov.model = 'spherical',
                      trend = trend.spatial(trend='1st', geodata = geodata_train, 
                                            add.to.trend = ~prec+temp+pres+rh+uwind+vwind),
                      messages = FALSE)
    
    # Kriging 수행을 위한 객체 생성
    krig_control = krige.control(type.krige = "OK", 
                                 trend.d = trend.spatial(trend='1st', geodata = geodata_train, 
                                                         add.to.trend = ~ prec + temp + pres + rh + uwind + vwind),
                                 trend.l = trend.spatial(trend = '1st', geodata = geodata_valid, 
                                                         add.to.trend = ~ prec + temp + pres + rh + uwind + vwind), 
                                 obj.model = geoR_fit)
    
    # Kriging 수행
    result = krige.conv(geodata_train, locations = geodata_valid$coords,
                        krige=krig_control)
  
    
    mse[i] = mean((result$predict-valid_kriging[,10])^2)
    mae[i] = mean(abs(result$predict-valid_kriging[,10]))
    
    Pred_class <- cut(result$predict,c(-0.1,12,35.5))
    levels(Pred_class)<-c(0,1)
    acc[i] = confusionMatrix(Pred_class,as.factor(valid_kriging[,11]))$over[1]
}

end_time <- Sys.time()
# cat("Time: ",end_time-start_time,"\n")

```

```{r}
# cv결과 요약
cat("------------------------------------ \n")
cat("Mean of MSE: ",mean(mse),"\n")
cat("SD of MSE: ",sd(mse),"\n")
cat("------------------------------------ \n")
cat("Mean of MAE: ",mean(mae),"\n")
cat("SD of MAE: ",sd(mae),"\n")
cat("------------------------------------ \n")
cat("Mean of Accuracy: ",mean(acc),"\n")
cat("SD of Accuracy: ",sd(acc),"\n")
cat("------------------------------------ \n")
```

# [CV] Cross Validation: Ordinary Kriging(NO X)

```{r}
mse_nx = mae_nx = acc_nx = c()

# start_time <- Sys.time()

for (i in 1:10){
  cat("Fold: ",i,"\n")
    idx = na.exclude(test_idx[,i+1])
    train_kriging=data_kriging[-idx,]
    valid_kriging=data_kriging[idx,]
    
    geodata_train = as.geodata(train_kriging, coords.col = 2:3, data.col = 10,covar.col = 4:9)
    geodata_valid = as.geodata(valid_kriging,coords.col = 2:3,data.col = 10,covar.col = 4:9)
    
    geoR_fit = likfit(geodata_train, ini.cov.pars = c(18, 0.5), negget=3,
                      cov.model = 'spherical', messages = FALSE)
    krig_control = krige.control(type.krige = "OK",  obj.model = geoR_fit)

    result = krige.conv(geodata_train, locations = geodata_valid$coords,krige=krig_control)
    
    mse_nx[i] = mean((result$predict-valid_kriging[,10])^2)
    mae_nx[i] = mean(abs(result$predict-valid_kriging[,10]))
    
    Pred_class <- cut(result$predict, c(-0.1,12,35.5))
    levels(Pred_class)<-c(0,1)
    acc_nx[i] = confusionMatrix(Pred_class,as.factor(valid_kriging[,11]))$over[1]
}

end_time <- Sys.time()

# cat("Time: ",end_time-start_time,"\n")

```

```{r}
# 결과 요약
cat("------------------------------------ \n")
cat("Mean of MSE: ",mean(mse_nx),"\n")
cat("SD of MSE: ",sd(mse_nx),"\n")
cat("------------------------------------ \n")
cat("Mean of MAE: ",mean(mae_nx),"\n")
cat("SD of MAE: ",sd(mae_nx),"\n")
cat("------------------------------------ \n")
cat("Mean of Accuracy: ",mean(acc_nx),"\n")
cat("SD of Accuracy: ",sd(acc_nx),"\n")
cat("------------------------------------ \n")
```

# Fixed Rank Kriging(FRK)

```{r}
# install.packages("sp") # FRK는 sp에서 사용하는 함수가 있어서 설치해야함
# install.packages("FRK")
library(sp)
library(FRK)
```

## Data Setting

우리가 사용하고 있는 데이터의 클래스는 `data.frame`이지만, FRK는 spatial object인 `SpatialPointsDataFrame` 혹은 `SpatialPolygonsDataFrame` 클래스를 사용합니다. 따라서, 우리는 `coordinates()` 함수를 사용하여 `SpatialPointsDataFrame` 객체를 생성합니다. 이때, 중요한 옵션은 다음과 같습니다. 이때, 우리가 사용하는 데이터는 좌표 기반이므로 `SpatialPointsDataFrame`을 사용하는 것입니다.

```{r}
rm(list=ls())

data_kriging2 <- read.csv("kriging2.csv", header = TRUE)
names(data_kriging2) <- c("index","long","lat","prec","temp","pres","rh","uwind","vwind","pm25","pm25_class","pm25_log")

us_metero <- read.csv("covariate0605.csv") # 기상 자료

set.seed(123)

FRK_train <- data_kriging2[,c("long","lat","pm25")]
coordinates(FRK_train) <- ~long+lat

FRK_data_BAUs <- us_metero
coordinates(FRK_data_BAUs) <- ~long+lat
FRK_data_BAUs.grid <- BAUs_from_points(FRK_data_BAUs)
```

## Basis Setting

```{r}
G <- auto_basis(manifold = plane(), # 2D plane
                 data = FRK_train, # data
                 nres = 3, # number of resolutions
                 type = "bisquare", # type of basis function
                 regular = 1) # place regularly in domain

show_basis(G) + # illustrate basis functions
  coord_fixed() + # fix aspect ratio
  xlab("") + # x-label
  ylab("") # y-labe

```

## Fitting and Prediction

```{r}
f <- pm25 ~ 1 + prec + temp + pres + rh + uwind + vwind

start_time <- Sys.time()
S <- FRK(f = f,
         data = list(FRK_train),
         BAUs = FRK_data_BAUs.grid,
         method = 'TMB',
         basis = G,
         simple_kriging_fixed = FALSE,
         regular = 0)

Pred <- predict(S, obs_fs = FALSE)
end_time <- Sys.time()
cat("Time: ",end_time-start_time,"\n")
```

## To data.frame

```{r}
# library(ggplot2)
BAUs_df <- as.data.frame(Pred)  # convert the BAUs to data frame
```

# [CV] Cross Validation: FRK

```{r}

```


```{r}
# mse_frk = mae_frk = acc_frk = c()
# 
# # start_time <- Sys.time()
# 
# for (i in 1:10){
#   cat("Fold: ",i,"\n")
#     idx = na.exclude(test_idx[,i+1])
#     
#     train_kriging=FRK_train[-idx,]
#     valid_kriging=FRK_train[idx,]
#     
#     
#     
#     geodata_train = as.geodata(train_kriging, coords.col = 2:3, data.col = 10,covar.col = 4:9)
#     geodata_valid = as.geodata(valid_kriging,coords.col = 2:3,data.col = 10,covar.col = 4:9)
#     
#     geoR_fit = likfit(geodata_train, ini.cov.pars = c(18, 0.5), negget=3,
#                       cov.model = 'spherical', messages = FALSE)
#     krig_control = krige.control(type.krige = "OK",  obj.model = geoR_fit)
# 
#     result = krige.conv(geodata_train, locations = geodata_valid$coords,krige=krig_control)
#     
#     mse_nx[i] = mean((result$predict-valid_kriging[,10])^2)
#     mae_nx[i] = mean(abs(result$predict-valid_kriging[,10]))
#     
#     Pred_class <- cut(result$predict, c(-0.1,12,35.5))
#     levels(Pred_class)<-c(0,1)
#     acc_nx[i] = confusionMatrix(Pred_class,as.factor(valid_kriging[,11]))$over[1]
# }
# 
# end_time <- Sys.time()

# cat("Time: ",end_time-start_time,"\n")

```




# CV 결과 저장

```{r}
# 위 CV 결과들을 하나의 csv 파일로 출력
result <- data.frame("MSE"=mse,"MAE"=mae,"ACC"=acc,"MSE_NX"=mse_nx,"MAE_NX"=mae_nx,"ACC_NX"=acc_nx)
write.csv(result,"Krig_CV_all.csv",row.names=FALSE)
```



# Spatial Prediction

## Data

여기서 불러온 데이터는 파이썬에서 DeepKriging을 통해 예측한 PM25 데이터입니다. 이 데이터는 `PM25_pred_0605.csv`로 저장되어 있습니다. 이 데이터는 다음과 같은 열을 가지고 있습니다.

 - `index`: 인덱스
 - `long`: 경도
 - `lat`: 위도
 - `prec`: 강수량
 - `temp`: 온도
 - `pres`: 기압
 - `rh`: 상대습도
 - `uwind`: 풍속
 - `vwind`: 풍향
 - `pm25`: DeepKriging을 통해 예측된 PM25

```{r}
pred_data = read.csv("PM25_pred_0605.csv")
names(pred_data)<- c("index","long","lat","prec","temp","pres","rh","uwind","vwind","pm25")
dim(pred_data)
```


```{r Kriging prediction}
geodata_train = as.geodata(data_kriging, coords.col = 2:3, data.col = 10, covar.col = 4:9)
geodata_pred = as.geodata(pred_data, coords.col = 2:3, data.col = 10, covar.col = 4:9)

start_time <- Sys.time()

geoR_fit = likfit(geodata_train, ini.cov.pars = c(18, 0.5), negget=3,
                  trend = trend.spatial(trend='1st', geodata = geodata_train, 
                                        add.to.trend = ~prec+temp+pres+rh+uwind+vwind),
                  messages = FALSE)

krig_control = krige.control(type.krige = "OK", 
                             trend.d = trend.spatial(trend='1st', geodata = geodata_train, 
                                                     add.to.trend = ~ prec + temp + pres + rh + uwind + vwind),
                             trend.l = trend.spatial(trend = '1st', geodata = geodata_pred, 
                                                     add.to.trend = ~ prec + temp + pres + rh + uwind + vwind),
                             obj.model = geoR_fit)

result = krige.conv(geodata_train, locations = geodata_pred$coords,krige=krig_control)

end_time <- Sys.time()
cat("Time: ",end_time-start_time,"\n")
```

```{r plots, message=FALSE}
# install.packages("fields")
library(fields) # 그림 그리려고 쓰는 패키지
DK_prediction <- pred_data[,10]
risk_pred <- read.csv("PM25_pred_risk_0605.csv")[,10]

# 이미 있는 자료 활용...
us_metero <- read.csv("covariate0605.csv") # 기상 자료

pm25_data <- read.csv("pm25_0605.csv") # 관측 자료

# par(mfrow=c(2,2), mar=c(2,3,1.5,2), mgp=c(1.5,0.5,0))

quilt.plot(pm25_data$Longitude, pm25_data$Latitude, pm25_data$PM25,
           zlim=c(0,25),main="(a) Observed")
# map("state",add=TRUE)

quilt.plot(us_metero$long, us_metero$lat, DK_prediction, zlim=c(0,25),
           main="(b) DeepKriging")
# map("state",add=TRUE)

quilt.plot(us_metero$long, us_metero$lat, risk_pred, zlim=c(0,1),main="(c) DeepKriging Risk")
# map("state",add=TRUE)

quilt.plot(us_metero$long,us_metero$lat,result$predict,zlim=c(0,25),main="(d) Universal Kriging")
# map("state",add=TRUE)

quilt.plot(BAUs_df$newdata.long, BAUs_df$newdata.lat, BAUs_df$newdata.p_mu, zlim=c(0,25),main="(e) FRK")

```

위 그림의 결과로 미루어보아 DeepKriging은 값이 낮은 지역을 좀 더 위글리 하게 맞춰서 전체적인 loss를 줄이는 방향으로 학습이 된것 같고, UK같은 경우는 관측된 지역의 값은 그대로 맞추기 때문에 값이 높은 지역에서는 DeepKriging보다 잘 맞추는 경향이 있는것 같습니다.






